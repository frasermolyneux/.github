import json
import os
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Optional, Tuple

import requests

GITHUB_TOKEN = os.environ.get("GITHUB_TOKEN")
OWNER = "frasermolyneux"
REPO = "platform-workloads"
WORKLOADS_PATH = "terraform/workloads"

ROOT = Path(__file__).resolve().parents[2]
WORKLOADS_OUT = ROOT / "docs" / "estate" / "workloads.md"
ROUTE_OUT = ROOT / "docs" / "estate" / "route-to-production.md"
PIPELINES_OUT = ROOT / "docs" / "estate" / "pipelines.md"

session = requests.Session()
session.headers.update({"Authorization": f"Bearer {GITHUB_TOKEN}", "Accept": "application/vnd.github+json"})


def github_contents(path: str) -> List[Dict]:
    url = f"https://api.github.com/repos/{OWNER}/{REPO}/contents/{path}"
    resp = session.get(url)
    resp.raise_for_status()
    return resp.json()


def fetch_workflows(repo: str) -> List[Dict]:
    url = f"https://api.github.com/repos/{OWNER}/{repo}/actions/workflows"
    resp = session.get(url)
    if resp.status_code == 404:
        return []
    resp.raise_for_status()
    payload = resp.json()
    return payload.get("workflows", [])


def find_badge(repo: str, workflows: List[Dict], candidates: List[str]) -> Optional[str]:
    for wf in workflows:
        path = wf.get("path", "").lower()
        if any(path.endswith(candidate) for candidate in candidates):
            badge_url = f"https://github.com/{OWNER}/{repo}/actions/workflows/{wf['path']}/badge.svg"
            link_url = f"https://github.com/{OWNER}/{repo}/actions/workflows/{wf['path']}"
            label = wf.get("name") or wf.get("path")
            return f"[![{label}]({badge_url})]({link_url})"
    return None


def workflow_badges(repo: str, workflows: List[Dict]) -> List[str]:
    badges: List[str] = []
    for wf in workflows:
        path = wf.get("path")
        if not path:
            continue
        badge_url = f"https://github.com/{OWNER}/{repo}/actions/workflows/{path}/badge.svg"
        link_url = f"https://github.com/{OWNER}/{repo}/actions/workflows/{path}"
        label = wf.get("name") or path
        badges.append(f"[![{label}]({badge_url})]({link_url})")
    return badges


def load_workloads() -> Dict[str, List[Dict]]:
    categories: Dict[str, List[Dict]] = {}
    for entry in github_contents(WORKLOADS_PATH):
        if entry["type"] != "dir" or entry["name"] == "examples":
            continue
        category = entry["name"]
        categories[category] = []
        for file_entry in github_contents(f"{WORKLOADS_PATH}/{category}"):
            if file_entry["type"] != "file" or not file_entry["name"].endswith(".json"):
                continue
            raw = session.get(file_entry["download_url"])
            raw.raise_for_status()
            payload = json.loads(raw.text)
            environments = payload.get("environments", [])
            categories[category].append({
                "name": payload.get("name", file_entry["name"].replace(".json", "")),
                "repo": payload.get("name", file_entry["name"].replace(".json", "")),
                "environments": [env.get("name") for env in environments if env.get("name")],
                "subscriptions": list({env.get("subscription") for env in environments if env.get("subscription")}),
            })
    return categories


def render_workloads(categories: Dict[str, List[Dict]]) -> str:
    lines = [
        "# Workload Catalog",
        "",
        "Generated from platform-workloads/terraform/workloads (excluding examples).",
        "",
    ]
    for category in sorted(categories.keys()):
        lines.append(f"## {category}")
        lines.append("")
        lines.append("| Workload | Environments | Subscriptions |")
        lines.append("| --- | --- | --- |")
        for workload in sorted(categories[category], key=lambda w: w["name"]):
            envs = ", ".join(workload["environments"]) if workload["environments"] else "-"
            subs = ", ".join(sorted(filter(None, workload["subscriptions"]))) or "-"
            repo_link = f"[{workload['repo']}](https://github.com/{OWNER}/{workload['repo']})"
            lines.append(f"| {repo_link} | {envs} | {subs} |")
        lines.append("")
    lines.append("---")
    lines.append("Generated by scripts/estate-sync/estate_sync.py")
    return "\n".join(lines)


def render_route_to_production(repos: List[Tuple[str, Optional[str], Optional[str]]]) -> str:
    lines = [
        "# Route to Production",
        "",
        "This page is generated from repository workflows. Badges link to the owning workflow so you can jump straight to failing runs.",
        "",
        "## Release pipelines",
        "",
        "| Repository | Release Pipeline | CI/Main |",
        "| --- | --- | --- |",
    ]
    for name, release_badge, ci_badge in sorted(repos, key=lambda r: r[0].lower()):
        release = release_badge or "Not configured"
        ci = ci_badge or "Not found"
        repo_link = f"[{name}](https://github.com/{OWNER}/{name})"
        lines.append(f"| {repo_link} | {release} | {ci} |")
    lines.append("")
    lines.append("---")
    lines.append("Generated by scripts/estate-sync/estate_sync.py")
    return "\n".join(lines)


def render_pipelines(categories: Dict[str, List[Dict]], repos: Dict[str, List[str]]) -> str:
    lines = [
        "# Pipeline Badges",
        "",
        "All workflow badges per workload. Badges link to the workflow definitions.",
        "",
        "| Workload | Workflows |",
        "| --- | --- |",
    ]

    workloads = []
    for category in categories.values():
        workloads.extend(category)

    for workload in sorted(workloads, key=lambda w: w["name"].lower()):
        repo_name = workload["repo"]
        badges = repos.get(repo_name, [])
        repo_link = f"[{workload['name']}](https://github.com/{OWNER}/{repo_name})"
        badge_list = " ".join(badges) if badges else "No workflows found"
        lines.append(f"| {repo_link} | {badge_list} |")

    lines.append("")
    lines.append("---")
    lines.append("Generated by scripts/estate-sync/estate_sync.py")
    return "\n".join(lines)


def main() -> None:
    categories = load_workloads()

    repo_names = sorted({w["repo"] for values in categories.values() for w in values})
    repo_badges: List[Tuple[str, Optional[str], Optional[str]]] = []
    repo_workflow_badges: Dict[str, List[str]] = {}
    for repo in repo_names:
        workflows = fetch_workflows(repo)
        release_badge = find_badge(repo, workflows, ["release-to-production.yml", "release-to-production.yaml"])
        ci_badge = find_badge(repo, workflows, ["ci.yml", "ci.yaml", "build.yml", "build.yaml", "tests.yml", "tests.yaml"])
        repo_badges.append((repo, release_badge, ci_badge))
        repo_workflow_badges[repo] = workflow_badges(repo, workflows)

    repo_lookup = {name: (release, ci) for name, release, ci in repo_badges}

    WORKLOADS_OUT.parent.mkdir(parents=True, exist_ok=True)
    WORKLOADS_OUT.write_text(render_workloads(categories), encoding="utf-8")
    ROUTE_OUT.write_text(render_route_to_production(repo_badges), encoding="utf-8")
    PIPELINES_OUT.write_text(render_pipelines(categories, repo_workflow_badges), encoding="utf-8")


if __name__ == "__main__":
    if not GITHUB_TOKEN:
        raise SystemExit("GITHUB_TOKEN is required")
    main()
