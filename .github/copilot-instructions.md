# Copilot Instructions

- Purpose: single repo dashboard for org workloads (pipelines, schedules, environments) published from docs/estate via GitHub Pages.
- Core generator: [scripts/estate-sync/estate_sync.py](scripts/estate-sync/estate_sync.py) fetches metadata and writes Markdown; do not hand-edit generated docs.
- Source of truth: workload metadata comes from platform-workloads/terraform/workloads JSON (read via GitHub API).
- Outputs (all autogenerated): [docs/estate/workloads.md](docs/estate/workloads.md), [docs/estate/route-to-production.md](docs/estate/route-to-production.md), [docs/estate/pipelines.md](docs/estate/pipelines.md), [docs/estate/pipeline-scheduling.md](docs/estate/pipeline-scheduling.md), repo pages under [docs/estate/repos/](docs/estate/repos), category pages under [docs/estate/categories/](docs/estate/categories).
- Navigation/footer: nav_line() injects Home/Workloads/Pipelines/Scheduling/Repos links; footer_lines() adds timestamp and auto-generated notice—keep these on new pages.
- Data collection: fetch_workflows() (GitHub Actions list) plus list_workflow_files() (directory crawl) to avoid missing files; workflow_badges() builds badges per workflow.
- Scheduling detection: extract_github_schedule() parses workflow YAML (PyYAML if present, regex fallback) and computes next run with croniter when installed; ADO schedules parsed from repo .azure-pipelines/*.yml via extract_ado_yaml_schedule().
- ADO integration: fetch_ado_pipelines() uses AZDO_PAT; ado_pipeline_badges() filters pipelines prefixed with repo name; repo detail links use project/definition ids.
- Aggregation helpers: gather_repo_details() merges environments, subscriptions, badges, workflows, schedules, ADO pipelines into per-repo dicts used by renderers.
- Rendering: render_workloads(), render_route_to_production(), render_pipelines(), render_scheduling(), render_repos_index(), render_repo_detail(), render_category_pages(); always go through write_markdown() to ensure directories exist.
- Caching pattern: project_pipeline_cache avoids repeated ADO API calls per project; reuse or expand this if adding more network fetches.
- Required env: GITHUB_TOKEN (mandatory); optional AZDO_PAT and AZDO_ORG (defaults to https://dev.azure.com/frasermolyneux). Script exits if GITHUB_TOKEN missing.
- Dependencies: requests required; PyYAML and croniter optional but recommended for full schedule parsing. No requirements.txt—pip install manually when running locally.
- Running locally: python scripts/estate-sync/estate_sync.py (from repo root). Outputs overwrite docs/estate files; review git diff after generation.
- GitHub Pages: configured via [docs/_config.yml](docs/_config.yml) using Cayman theme; Markdown in docs/estate is the published site content.
- Repo detail pages: include repo link, ADO project (if any), environments/subscriptions from workload metadata, badges (GitHub+ADO), schedules, workflow file list with links, and ADO pipelines table.
- Workload/category mapping: load_workloads() builds categories from workload JSON directories; each workload maps to repo name equal to workload name.
- Error handling: logging via stderr; missing directories/files logged but script continues (best-effort generation).
- Modifying badge detection: find_badge() looks for release-to-production and CI naming conventions; adjust candidate filenames if standards change.
- Keep ASCII in generated content; avoid manual edits to generated Markdown and update the generator instead.
- When adding new outputs, extend nav_line/footer_lines for consistency and route new renderers through main() with write_markdown().
- Preferred style: small, readable tables; concise labels; avoid inline HTML except existing footer comment.
- Tests: none present; verify changes by running generator and inspecting docs/estate outputs.

Feedback: If anything here is unclear or missing, tell me which sections to expand or which workflows need more detail.
